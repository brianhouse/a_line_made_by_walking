{% extends "page.html" %}

https://developer.mozilla.org/en-US/docs/Web/API/Detecting_device_orientation
https://www.html5rocks.com/en/tutorials/device/orientation/
http://www.euclideanspace.com/maths/geometry/rotations/conversions/eulerToMatrix/index.htm  -- weird order

{% block head %}
    <script type="text/javascript">

        var acceleration;
        var orient; // 'orientation' causes problems somehow
        var absolute;

        console.log("Hello World!");

        if (window.DeviceOrientationEvent) {
            // alert("DeviceOrientation is supported");
        } else {
            alert("DeviceOrientation is not supported");
        }   

        window.ondevicemotion = function(e) {
            acceleration = [e.acceleration.x, e.acceleration.y, e.acceleration.z];   
            // acceleration = [e.acceleration.x, 0, 0];             
            $('#display_x').html("x: " + acceleration[0]);  // top to bottom
            $('#display_y').html("y: " + acceleration[1]);  // side to side
            $('#display_z').html("z: " + acceleration[2]);  // away from the screen / into the Earth

            if (orient == undefined) return;

            absolute = absoluteAcceleration(acceleration[0], acceleration[1], acceleration[2], orient[0], orient[1], orient[2]);
            $('#display_xa').html("xa: " + absolute[0]);
            $('#display_ya').html("ya: " + absolute[1]);
            $('#display_za').html("za: " + absolute[2]);

            drawScopes();
        }

        window.ondeviceorientation = function(e) {

            // this is euler angle offset from neutral position -- lying flat on a table, with the top towards north

                                                        // heading (compass) 0 is north, clockwise   -- rotation around z-axis
            if (e.webkitCompassHeading) {
                var alpha = e.webkitCompassHeading;     // on iphone, alpha returns the offset from the first request
            } else {
                var alpha = e.alpha;          
            }            
            var beta = e.beta;                          // elevation (degrees tilted up) 0 is horizontal -- rotation around x-axis
            // var beta = ((e.beta + 180) + 180) % 360; // (make 360 instead of -180, 180)
            var gamma = e.gamma;                        // bank (degrees tilted right) 0 is horizontal   -- rotation around y-axis
                                                        // cant fix bank, doesnt know when it's upside down

            orient = [alpha, beta, gamma];
            // orient = [0, 0, gamma];
            
            $('#display_alpha').html("heading: " + Math.floor(orient[0]));
            $('#display_beta').html("elevation: " + Math.floor(orient[1]));
            $('#display_gamma').html("bank: " + Math.floor(orient[2]));

            $('#arrow_alpha').css({
                "-webkit-transform": "rotate(" + orient[0] + "deg)",
                "-moz-transform": "rotate(" + orient[0] + "deg)",
                "transform": "rotate(" + orient[0] + "deg)"
            });

            $('#arrow_beta').css({
                "-webkit-transform": "rotate(" + orient[1] + "deg)",
                "-moz-transform": "rotate(" + orient[1] + "deg)",
                "transform": "rotate(" + orient[1] + "deg)"
            });

            $('#arrow_gamma').css({
                "-webkit-transform": "rotate(" + orient[2] + "deg)",
                "-moz-transform": "rotate(" + orient[2] + "deg)",
                "transform": "rotate(" + orient[2] + "deg)"
            });            
        }

        function degreesToRadians(degrees) {
            return degrees * (Math.PI / 180.0);
        }

        function eulerToMatrix(heading, elevation, bank) {

            // calculate a matrix from euler orientation values
            // note the axes -- this can be different, eg, many put y as away from earth, rather than north-south
            // by convention, I'm passing heading first, even though it's z-axis rotation
            // the order applied to matrix multiplication is bank, heading, elevation (yzx) ... ?
            // the matrix indices are _column first_, so it's all the xs, then the ys, then the zs

            var e = degreesToRadians(elevation);    // x-axis
            var b = degreesToRadians(bank);         // y-axis
            var h = degreesToRadians(heading);      // z-axis (toward Earth)            
            var ce = Math.cos(e);
            var se = Math.sin(e);
            var cb = Math.cos(b);
            var sb = Math.sin(b);
            var ch = Math.cos(h);
            var sh = Math.sin(h);            
            var m = [[null, null, null], [null, null, null], [null, null, null]]; // columns

            // xs
            m[0][0] = cb*ch;
            m[0][1] = -cb*sh*ce + sb*se;
            m[0][2] = cb*sh*se + sb*ce;

            // ys
            m[1][0] = sh;
            m[1][1] = ch*ce;
            m[1][2] = -ch*se;

            // zs
            m[2][0] = -sb*ch;
            m[2][1] = sb*sh*ce + cb*se;
            m[2][2] = -sb*sh*se + cb*ce;

            return m

            // vs this calculation, it's just that the h,e,b labels have been rotated
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/eulerToMatrix/index.htm

        }

        function absoluteAcceleration(x, y, z, heading, elevation, bank) {
            // multiply acceleration vector by the orientation matrix
            var m = eulerToMatrix(heading, elevation, bank);
            var xa = x * m[0][0] + y * m[0][1] + z * m[0][2];
            var ya = x * m[1][0] + y * m[1][1] + z * m[1][2];
            var za = x * m[2][0] + y * m[2][1] + z * m[2][2];            
            return [xa, ya, za];
        }

        function drawScopes() {

            var canvas = document.getElementById("accelerationCanvas");
            var ctx = canvas.getContext("2d");
            // ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, canvas.height / 2);
            ctx.lineTo((acceleration[0] * 5.0) + (canvas.width/2), (acceleration[1] * 5.0) + (canvas.height/2));
            ctx.stroke();

            var canvas = document.getElementById("absoluteCanvas");
            var ctx = canvas.getContext("2d");
            // ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, canvas.height / 2);
            ctx.lineTo((absolute[0] * 5.0) + (canvas.width/2), (absolute[1] * 5.0) + (canvas.height/2));
            ctx.stroke();

        }

        // window.ondevicemotion = null;
        // window.ondeviceorientation = null;
        // eulerToMatrix(0, 0, 90);

    </script>
{% endblock head %}

{% block body %}

    <div id="orientation">    

    <!-- orientation -->
    <span id="display_alpha">heading:</span><br />
    <div style="text-align: center">
        <img id="arrow_alpha" style="width: 25px; height: 25px; margin: auto; background-color: black;" src="/static/img/compass.png" />
    </div>
    <br />    
    <span id="display_beta">elevation:</span><br />
    <div style="text-align: center">
        <img id="arrow_beta" style="width: 25px; height: 25px; margin: auto; background-color: black;" src="/static/img/compass.png" />
    </div>
    <br />    
    <span id="display_gamma">bank:</span><br />        
    <div style="text-align: center">
        <img id="arrow_gamma" style="width: 25px; height: 25px; margin: auto; background-color: black;" src="/static/img/compass.png" />
    </div>
    <br />     

    <!-- acceleration -->
    <span id="display_x">x:</span><br />
    <span id="display_y">y:</span><br />
    <span id="display_z">z:</span><br />
    <canvas id="accelerationCanvas" width="100" height="100" style="border:1px solid black;"></canvas>                
    <br />

    <!-- absolute acceleration -->
    <span id="display_xa">xa:</span><br />
    <span id="display_ya">ya:</span><br />
    <span id="display_za">za:</span><br />
    <canvas id="absoluteCanvas" width="100" height="100" style="border:1px solid black;"></canvas>                    
    <br />
   
   </div>
{% endblock body %}

